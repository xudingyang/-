<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
  // 什么是作用域：
  // 作用域不是内存中具体的范围，看不见摸不着。
  // 作用域是一组规则，一组用于确定在何处以及如何查找变量的规则。能查找到变量的地方，就是在作用域之内。

  // 词法作用域  动态作用域
  // 词法作用域是在定义时确定的，而动态作用域是在运行时确定的

  // 词法作用域：c java javascript 等常见语言都是词法作用域

  // 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定
  // call和apply就是改变这个规则的。

  // 注意：JS里没用块级作用域
  // 即 for(var i = 0; i < 5; i++)循环里的 i ，出了for代码块还是能访问到的，而且也有变量提升

  /*
   * 词法作用域规则：
   * 1 函数允许访问函数外的数据
   * 2 js中，能产生作用域的只有函数。
   *      其实严格来说，也不是这样，ES6之前，还有下边3种能产生作用域。
   *      ①ES3开始规定的try...catch中的catch分句会创建一个块作用域。有些ES6转ES5的框架就是借catch产生作用域的。
   *      ②with语句，也会产生块作用域
   *      ③严格模式下的eval()
   * 3 作用域规则首先使用提升规则分析
   *       提升规则：函数提升、变量提升。
   * 4 如果当前作用域中有了该变量，就不考虑外边的同名变量了
   * */

  // 为什么eval()和with()这类能注入代码的方式，会降低性能？
  // 因为这些代码会在运行时修改或创建新的作用域。
  // js引擎会在编译阶段进行性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符
  // 而eval和with中的内容是不确定的，可能是程序运行后用户在输入的代码字符串，而这些后来添加的代码字符串可能修改作用域，于是提前做的优化都是徒劳的。


  var a = 123

  function f1 () {
    console.log(a)
    // 当上边这句执行的时候，
    // 先在log函数作用域里面找，找不到，去外边一层f1中找
    // f1中也没有，继续去外层找
    // 找到了全局的 a
    // 绝对不会找到f2函数作用域中的a
  }
  function f2 () {
    var a = 456
    f1()
  }
  f2()   // 打印 123 说明f1里的a在a写出来的时候，就确定作用域了


  // catch分句产生块作用域。
  {
    try {
      throw undefined
    } catch (e) {
      e = 2
      console.log(e)   // 打印 2
    }
    console.log(e)     // e is not defined
  }
</script>
</body>
</html>