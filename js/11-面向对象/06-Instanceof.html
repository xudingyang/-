<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

</body>
</html>
<script>

  // 判断类型
  function Hehe () {
    this.name = 'Rose'
  }
  var a = new Hehe()
  if (a instanceof Hehe) {
    console.log('hehe')
  }
  if (a.constructor === Hehe) {
    console.log('constructor')
  }

  // 判断一个构造函数的原型是不是存在于该对象的原型链上

  // instanceof表示的就是一种继承关系，或者原型链的结构。
  // instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。
  // instanceof的判断队则是：沿着A的proto这条线来找，同时沿着B的prototype这条线来找，
  // 如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。

  console.log(a instanceof Object) // true
  // a顺着原型链往上找，会找到Object.prototype，所以Object是a的父类型
  // js里的继承，实际上是继承原型，也就是说，在Object的原型链上的 ，都继承于Object。
  // 由此得出结论，所有对象(包括Function)都来自Object
  // 但是Object构造函数又来自于Function
  // 这就是鸡生蛋蛋生鸡的问题

</script>